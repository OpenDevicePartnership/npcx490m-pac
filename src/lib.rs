#![doc = "Peripheral access API for NPCX490M microcontrollers (generated using svd2rust v0.35.0 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.35.0/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
#[cfg(feature = "rt")]
pub use self::Interrupt as interrupt;
use core::marker::PhantomData;
use core::ops::Deref;
pub use cortex_m::peripheral::Peripherals as CorePeripherals;
pub use cortex_m::peripheral::{CBP, CPUID, DCB, DWT, FPB, FPU, ITM, MPU, NVIC, SCB, SYST, TPIU};
#[cfg(feature = "rt")]
pub use cortex_m_rt::interrupt;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic;
#[cfg(feature = "rt")]
extern "C" {
    fn KBS();
    fn PM_OBE();
    fn PECI();
    fn WKINTD_0();
    fn DP80();
    fn WKINTA_0();
    fn SMB7();
    fn MFT16_1();
    fn ADC_IREF();
    fn WKINTE_0();
    fn GDMA1();
    fn SMB0();
    fn SMB1();
    fn WKINTC_0();
    fn SMB6();
    fn ITIM32_3();
    fn ESPI_SHI();
    fn SMB4();
    fn SMB5();
    fn PS2();
    fn ADC_EREF();
    fn MFT16_2();
    fn SHM();
    fn KBC_IBF();
    fn PM_IBF();
    fn ITIM32_2();
    fn ITIM32_1();
    fn I3C1_MDMA5();
    fn FLM();
    fn WKINTB_0();
    fn CR_UART2_MDMA2();
    fn CR_UART1_MDMA1();
    fn RNG();
    fn WKINTF_0();
    fn SMB2();
    fn SMB3();
    fn CR_UART3_MDMA3();
    fn CR_UART4_MDMA4();
    fn PKA();
    fn MFT16_3();
    fn WKINTG_0();
    fn ITIM32_4();
    fn ITIM32_5();
    fn ITIM32_6();
    fn WKINTH_0();
    fn WKINTA_1();
    fn WKINTB_1();
    fn WKINTC_1();
    fn WKINTD_1();
    fn WKINTE_1();
    fn WKINTF_1();
    fn WKINTG_1();
    fn WKINTH_1();
    fn WKINTG_2();
    fn KBC_OBE();
    fn SPIP();
    fn WKINTF_2();
    fn WKINTA_2();
    fn WKINTB_2();
    fn WKINTC_2();
    fn WKINTD_2();
    fn WKINTE_2();
    fn GDMA2();
    fn I3C2_MDMA6();
    fn I3C3_MDMA7();
    fn ITIM64();
    fn WKINTH_2();
}
#[doc(hidden)]
#[repr(C)]
pub union Vector {
    _handler: unsafe extern "C" fn(),
    _reserved: u32,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle]
pub static __INTERRUPTS: [Vector; 83] = [
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: KBS },
    Vector { _handler: PM_OBE },
    Vector { _handler: PECI },
    Vector { _handler: WKINTD_0 },
    Vector { _handler: DP80 },
    Vector { _handler: WKINTA_0 },
    Vector { _handler: SMB7 },
    Vector { _handler: MFT16_1 },
    Vector { _handler: ADC_IREF },
    Vector { _handler: WKINTE_0 },
    Vector { _handler: GDMA1 },
    Vector { _handler: SMB0 },
    Vector { _handler: SMB1 },
    Vector { _handler: WKINTC_0 },
    Vector { _handler: SMB6 },
    Vector { _handler: ITIM32_3 },
    Vector { _handler: ESPI_SHI },
    Vector { _handler: SMB4 },
    Vector { _handler: SMB5 },
    Vector { _handler: PS2 },
    Vector { _handler: ADC_EREF },
    Vector { _handler: MFT16_2 },
    Vector { _handler: SHM },
    Vector { _handler: KBC_IBF },
    Vector { _handler: PM_IBF },
    Vector { _handler: ITIM32_2 },
    Vector { _handler: ITIM32_1 },
    Vector {
        _handler: I3C1_MDMA5,
    },
    Vector { _handler: FLM },
    Vector { _handler: WKINTB_0 },
    Vector {
        _handler: CR_UART2_MDMA2,
    },
    Vector {
        _handler: CR_UART1_MDMA1,
    },
    Vector { _handler: RNG },
    Vector { _handler: WKINTF_0 },
    Vector { _handler: SMB2 },
    Vector { _handler: SMB3 },
    Vector {
        _handler: CR_UART3_MDMA3,
    },
    Vector {
        _handler: CR_UART4_MDMA4,
    },
    Vector { _handler: PKA },
    Vector { _handler: MFT16_3 },
    Vector { _handler: WKINTG_0 },
    Vector { _handler: ITIM32_4 },
    Vector { _handler: ITIM32_5 },
    Vector { _handler: ITIM32_6 },
    Vector { _handler: WKINTH_0 },
    Vector { _handler: WKINTA_1 },
    Vector { _handler: WKINTB_1 },
    Vector { _handler: WKINTC_1 },
    Vector { _handler: WKINTD_1 },
    Vector { _handler: WKINTE_1 },
    Vector { _handler: WKINTF_1 },
    Vector { _handler: WKINTG_1 },
    Vector { _handler: WKINTH_1 },
    Vector { _handler: WKINTG_2 },
    Vector { _handler: KBC_OBE },
    Vector { _handler: SPIP },
    Vector { _reserved: 0 },
    Vector { _handler: WKINTF_2 },
    Vector { _handler: WKINTA_2 },
    Vector { _handler: WKINTB_2 },
    Vector { _handler: WKINTC_2 },
    Vector { _handler: WKINTD_2 },
    Vector { _handler: WKINTE_2 },
    Vector { _handler: GDMA2 },
    Vector {
        _handler: I3C2_MDMA6,
    },
    Vector {
        _handler: I3C3_MDMA7,
    },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: ITIM64 },
    Vector { _reserved: 0 },
    Vector { _handler: WKINTH_2 },
];
#[doc = r"Enumeration of all the interrupts."]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum Interrupt {
    #[doc = "2 - Automatic Keyboard Scan interrupt"]
    KBS = 2,
    #[doc = "3 - Host I/F Power Management Channel 1 or Channel 2 or Channel 3 or Channel 4, Output Buffer Empty interrupt"]
    PM_OBE = 3,
    #[doc = "4 - PECI 4.0 event"]
    PECI = 4,
    #[doc = "5 - MIWU0 - WKINTD_0 (GPIO, PS/2, TA2, TB2, SMBus, MTC)"]
    WKINTD_0 = 5,
    #[doc = "6 - Debug Port 80 interrupt"]
    DP80 = 6,
    #[doc = "7 - MIWU0 - WKINTA_0 (GPIO)"]
    WKINTA_0 = 7,
    #[doc = "8 - SMB7 module interrupt"]
    SMB7 = 8,
    #[doc = "9 - MFT16-1 (MFT16_INT1 or MFT16_INT2)"]
    MFT16_1 = 9,
    #[doc = "10 - ADC_IREF interrupt"]
    ADC_IREF = 10,
    #[doc = "11 - MIWU0 - WKINTE_0 (GPIO, Host access, SMBus, nLRESET/nPLTRST)"]
    WKINTE_0 = 11,
    #[doc = "12 - GDMA1 interrupt"]
    GDMA1 = 12,
    #[doc = "13 - SMB0 module interrupt"]
    SMB0 = 13,
    #[doc = "14 - SMB1 module interrupt"]
    SMB1 = 14,
    #[doc = "15 - MIWU0 - WKINTC_0 (GPIO, TB1)"]
    WKINTC_0 = 15,
    #[doc = "16 - SMB6 module interrupt"]
    SMB6 = 16,
    #[doc = "17 - ITIM32-3 interrupt"]
    ITIM32_3 = 17,
    #[doc = "18 - eSPI interrupt or SHI interrupt"]
    ESPI_SHI = 18,
    #[doc = "19 - SMB4 module interrupt"]
    SMB4 = 19,
    #[doc = "20 - SMB5 module interrupt"]
    SMB5 = 20,
    #[doc = "21 - PS/2 shift mechanism (PSINT1)"]
    PS2 = 21,
    #[doc = "22 - ADC_EREF interrupt"]
    ADC_EREF = 22,
    #[doc = "23 - MFT16-2 (MFT16_INT1 or MFT16_INT2)"]
    MFT16_2 = 23,
    #[doc = "24 - Shared Memory module interrupt"]
    SHM = 24,
    #[doc = "25 - Host I/F Keyboard/Mouse channel Input Buffer Full"]
    KBC_IBF = 25,
    #[doc = "26 - Host I/F Power Management Channel 1 or Channel 2 or Channel 3 or Channel 4, Input Buffer Full"]
    PM_IBF = 26,
    #[doc = "27 - ITIM32-2 interrupt"]
    ITIM32_2 = 27,
    #[doc = "28 - ITIM32-1 interrupt"]
    ITIM32_1 = 28,
    #[doc = "29 - I3CI1 module interrupt or MDMA5 module interrupt"]
    I3C1_MDMA5 = 29,
    #[doc = "30 - FLM module interrupt"]
    FLM = 30,
    #[doc = "31 - MIWU0 - WKINTB_0 (GPIO, TA1, MSWC wake-up - MSWCI, TWD system tick - T0OUT)"]
    WKINTB_0 = 31,
    #[doc = "32 - CR_UART2 module interrupt or MDMA2 module interrupt"]
    CR_UART2_MDMA2 = 32,
    #[doc = "33 - CR_UART1 module interrupt or MDMA1 module interrupt"]
    CR_UART1_MDMA1 = 33,
    #[doc = "34 - RNG modules (see RNGINT_MD bit on page 77)"]
    RNG = 34,
    #[doc = "35 - MIWU0 - WKINTF_0 (GPIO)"]
    WKINTF_0 = 35,
    #[doc = "36 - SMB2 module interrupt"]
    SMB2 = 36,
    #[doc = "37 - SMB3 module interrupt"]
    SMB3 = 37,
    #[doc = "38 - CR_UART3 module interrupt or MDMA3 module interrupt"]
    CR_UART3_MDMA3 = 38,
    #[doc = "39 - CR_UART4 module interrupt or MDMA4 module interrupt"]
    CR_UART4_MDMA4 = 39,
    #[doc = "40 - PKA (RSA-2048 accelerator) module interrupt"]
    PKA = 40,
    #[doc = "41 - MFT16-3 (MFT16_INT1 or MFT16_INT2)"]
    MFT16_3 = 41,
    #[doc = "42 - MIWU0 - WKINTG_0 (GPIO, TB1, nINTRUDER1)"]
    WKINTG_0 = 42,
    #[doc = "43 - ITIM32-4 interrupt"]
    ITIM32_4 = 43,
    #[doc = "44 - ITIM32-5 interrupt"]
    ITIM32_5 = 44,
    #[doc = "45 - ITIM32-6 interrupt"]
    ITIM32_6 = 45,
    #[doc = "46 - MIWU0 - WKINTH_0 (GPIO, I3C1_SDA)"]
    WKINTH_0 = 46,
    #[doc = "47 - MIWU1 - WKINTA_1 (GPIO)"]
    WKINTA_1 = 47,
    #[doc = "48 - MIWU1 - WKINTB_1 (GPIO, I3C3_SDA)"]
    WKINTB_1 = 48,
    #[doc = "49 - MIWU1 - WKINTC_1 (Keyboard Scan, GPIO)"]
    WKINTC_1 = 49,
    #[doc = "50 - MIWU1 - WKINTD_1 (PS/2, GPIO)"]
    WKINTD_1 = 50,
    #[doc = "51 - MIWU1 - WKINTE_1 (GPIO, TA1, RI)"]
    WKINTE_1 = 51,
    #[doc = "52 - MIWU1 - WKINTF_1 (GPIO, I3C2_SDA, SHI_CS)"]
    WKINTF_1 = 52,
    #[doc = "53 - MIWU1 - WKINTG_1 (PS/2, GPIO, TB2, INTRUDER2)"]
    WKINTG_1 = 53,
    #[doc = "54 - MIWU1 - WKINTH_1 (PS/2, PWRGD, CR_SIN1, TA2, GPIO)"]
    WKINTH_1 = 54,
    #[doc = "55 - MIWU2 - WKINTG_2 (SMBus, CR_SIN2, CR_SIN3, CR_SIN4, I3C1_ADRW, I3C1_RSTW)"]
    WKINTG_2 = 55,
    #[doc = "56 - Host I/F Keyboard/Mouse channel Output Buffer Empty"]
    KBC_OBE = 56,
    #[doc = "57 - SPIP module interrupt"]
    SPIP = 57,
    #[doc = "59 - MIWU2 - WKINTF_2 (GPIO, LCT Event, SMBus)"]
    WKINTF_2 = 59,
    #[doc = "60 - MIWU2 - WKINTA_2 (VW02x and VW03x)"]
    WKINTA_2 = 60,
    #[doc = "61 - MIWU2 - WKINTB_2 (VW07x and VW41x)"]
    WKINTB_2 = 61,
    #[doc = "62 - MIWU2 - WKINTC_2 (VW42x and VW43x)"]
    WKINTC_2 = 62,
    #[doc = "63 - MIWU2 - WKINTD_2 (VW44x and VW47x)"]
    WKINTD_2 = 63,
    #[doc = "64 - MIWU2 - WKINTE_2 (VW33x)"]
    WKINTE_2 = 64,
    #[doc = "65 - GDMA2 interrupt"]
    GDMA2 = 65,
    #[doc = "66 - I3CI2 module interrupt or MDMA6 module interrupt"]
    I3C2_MDMA6 = 66,
    #[doc = "67 - I3CI3 module interrupt or MDMA7 module interrupt"]
    I3C3_MDMA7 = 67,
    #[doc = "80 - ITIM64 interrupt"]
    ITIM64 = 80,
    #[doc = "82 - MIWU2 - WKINTH_2 (I3Cn_ADRW, I3Cn_RSTW (n = 2,3))"]
    WKINTH_2 = 82,
}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        self as u16
    }
}
#[doc = "ADC_IREF"]
pub struct AdcIref {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AdcIref {}
impl AdcIref {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const adc_iref::RegisterBlock = 0x400d_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const adc_iref::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for AdcIref {
    type Target = adc_iref::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AdcIref {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AdcIref").finish()
    }
}
#[doc = "ADC_IREF"]
pub mod adc_iref;
#[doc = "ADC_EREF"]
pub struct AdcEref {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AdcEref {}
impl AdcEref {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const adc_eref::RegisterBlock = 0x400d_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const adc_eref::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for AdcEref {
    type Target = adc_eref::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AdcEref {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AdcEref").finish()
    }
}
#[doc = "ADC_EREF"]
pub mod adc_eref;
#[doc = "BBRM"]
pub struct Bbrm {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Bbrm {}
impl Bbrm {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const bbrm::RegisterBlock = 0x400a_f100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const bbrm::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Bbrm {
    type Target = bbrm::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Bbrm {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Bbrm").finish()
    }
}
#[doc = "BBRM"]
pub mod bbrm;
#[doc = "CORE2HOST"]
pub struct Core2host {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Core2host {}
impl Core2host {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const core2host::RegisterBlock = 0x4000_e000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const core2host::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Core2host {
    type Target = core2host::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Core2host {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Core2host").finish()
    }
}
#[doc = "CORE2HOST"]
pub mod core2host;
#[doc = "CR_UART1"]
pub struct CrUart1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CrUart1 {}
impl CrUart1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cr_uart1::RegisterBlock = 0x400e_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cr_uart1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for CrUart1 {
    type Target = cr_uart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CrUart1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CrUart1").finish()
    }
}
#[doc = "CR_UART1"]
pub mod cr_uart1;
#[doc = "CR_UART2"]
pub struct CrUart2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CrUart2 {}
impl CrUart2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cr_uart1::RegisterBlock = 0x400e_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cr_uart1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for CrUart2 {
    type Target = cr_uart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CrUart2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CrUart2").finish()
    }
}
#[doc = "CR_UART2"]
pub use self::cr_uart1 as cr_uart2;
#[doc = "CR_UART3"]
pub struct CrUart3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CrUart3 {}
impl CrUart3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cr_uart1::RegisterBlock = 0x400e_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cr_uart1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for CrUart3 {
    type Target = cr_uart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CrUart3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CrUart3").finish()
    }
}
#[doc = "CR_UART3"]
pub use self::cr_uart1 as cr_uart3;
#[doc = "CR_UART4"]
pub struct CrUart4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CrUart4 {}
impl CrUart4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cr_uart1::RegisterBlock = 0x400e_6000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cr_uart1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for CrUart4 {
    type Target = cr_uart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CrUart4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CrUart4").finish()
    }
}
#[doc = "CR_UART4"]
pub use self::cr_uart1 as cr_uart4;
#[doc = "DEV"]
pub struct Dev {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dev {}
impl Dev {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dev::RegisterBlock = 0x400c_3000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dev::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dev {
    type Target = dev::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dev {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dev").finish()
    }
}
#[doc = "DEV"]
pub mod dev;
#[doc = "ESPI"]
pub struct Espi {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Espi {}
impl Espi {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const espi::RegisterBlock = 0x4000_a000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const espi::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Espi {
    type Target = espi::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Espi {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Espi").finish()
    }
}
#[doc = "ESPI"]
pub mod espi;
#[doc = "FIU_0"]
pub struct Fiu0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Fiu0 {}
impl Fiu0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fiu_0::RegisterBlock = 0x4002_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fiu_0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Fiu0 {
    type Target = fiu_0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Fiu0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Fiu0").finish()
    }
}
#[doc = "FIU_0"]
pub mod fiu_0;
#[doc = "FIU_1"]
pub struct Fiu1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Fiu1 {}
impl Fiu1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fiu_0::RegisterBlock = 0x4002_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fiu_0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Fiu1 {
    type Target = fiu_0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Fiu1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Fiu1").finish()
    }
}
#[doc = "FIU_1"]
pub use self::fiu_0 as fiu_1;
#[doc = "FLM"]
pub struct Flm {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Flm {}
impl Flm {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const flm::RegisterBlock = 0x400f_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const flm::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Flm {
    type Target = flm::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Flm {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Flm").finish()
    }
}
#[doc = "FLM"]
pub mod flm;
#[doc = "GDMA1"]
pub struct Gdma1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gdma1 {}
impl Gdma1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gdma1::RegisterBlock = 0x4001_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gdma1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gdma1 {
    type Target = gdma1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gdma1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gdma1").finish()
    }
}
#[doc = "GDMA1"]
pub mod gdma1;
#[doc = "GDMA2"]
pub struct Gdma2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gdma2 {}
impl Gdma2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gdma1::RegisterBlock = 0x4001_1a00 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gdma1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gdma2 {
    type Target = gdma1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gdma2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gdma2").finish()
    }
}
#[doc = "GDMA2"]
pub use self::gdma1 as gdma2;
#[doc = "GPIO0"]
pub struct Gpio0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpio0 {}
impl Gpio0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio0::RegisterBlock = 0x4008_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gpio0 {
    type Target = gpio0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpio0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpio0").finish()
    }
}
#[doc = "GPIO0"]
pub mod gpio0;
#[doc = "GPIO1"]
pub struct Gpio1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpio1 {}
impl Gpio1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio0::RegisterBlock = 0x4008_3000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gpio1 {
    type Target = gpio0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpio1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpio1").finish()
    }
}
#[doc = "GPIO1"]
pub use self::gpio0 as gpio1;
#[doc = "GPIO2"]
pub struct Gpio2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpio2 {}
impl Gpio2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio0::RegisterBlock = 0x4008_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gpio2 {
    type Target = gpio0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpio2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpio2").finish()
    }
}
#[doc = "GPIO2"]
pub use self::gpio0 as gpio2;
#[doc = "GPIO3"]
pub struct Gpio3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpio3 {}
impl Gpio3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio0::RegisterBlock = 0x4008_7000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gpio3 {
    type Target = gpio0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpio3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpio3").finish()
    }
}
#[doc = "GPIO3"]
pub use self::gpio0 as gpio3;
#[doc = "GPIO4"]
pub struct Gpio4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpio4 {}
impl Gpio4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio0::RegisterBlock = 0x4008_9000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gpio4 {
    type Target = gpio0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpio4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpio4").finish()
    }
}
#[doc = "GPIO4"]
pub use self::gpio0 as gpio4;
#[doc = "GPIO5"]
pub struct Gpio5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpio5 {}
impl Gpio5 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio0::RegisterBlock = 0x4008_b000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gpio5 {
    type Target = gpio0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpio5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpio5").finish()
    }
}
#[doc = "GPIO5"]
pub use self::gpio0 as gpio5;
#[doc = "GPIO6"]
pub struct Gpio6 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpio6 {}
impl Gpio6 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio0::RegisterBlock = 0x4008_d000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gpio6 {
    type Target = gpio0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpio6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpio6").finish()
    }
}
#[doc = "GPIO6"]
pub use self::gpio0 as gpio6;
#[doc = "GPIO7"]
pub struct Gpio7 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpio7 {}
impl Gpio7 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio0::RegisterBlock = 0x4008_f000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gpio7 {
    type Target = gpio0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpio7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpio7").finish()
    }
}
#[doc = "GPIO7"]
pub use self::gpio0 as gpio7;
#[doc = "GPIO8"]
pub struct Gpio8 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpio8 {}
impl Gpio8 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio0::RegisterBlock = 0x4009_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gpio8 {
    type Target = gpio0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpio8 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpio8").finish()
    }
}
#[doc = "GPIO8"]
pub use self::gpio0 as gpio8;
#[doc = "GPIO9"]
pub struct Gpio9 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpio9 {}
impl Gpio9 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio0::RegisterBlock = 0x4009_3000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gpio9 {
    type Target = gpio0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpio9 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpio9").finish()
    }
}
#[doc = "GPIO9"]
pub use self::gpio0 as gpio9;
#[doc = "GPIOA"]
pub struct Gpioa {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpioa {}
impl Gpioa {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio0::RegisterBlock = 0x4009_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gpioa {
    type Target = gpio0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpioa {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpioa").finish()
    }
}
#[doc = "GPIOA"]
pub use self::gpio0 as gpioa;
#[doc = "GPIOB"]
pub struct Gpiob {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpiob {}
impl Gpiob {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio0::RegisterBlock = 0x4009_7000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gpiob {
    type Target = gpio0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpiob {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpiob").finish()
    }
}
#[doc = "GPIOB"]
pub use self::gpio0 as gpiob;
#[doc = "GPIOC"]
pub struct Gpioc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpioc {}
impl Gpioc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio0::RegisterBlock = 0x4009_9000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gpioc {
    type Target = gpio0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpioc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpioc").finish()
    }
}
#[doc = "GPIOC"]
pub use self::gpio0 as gpioc;
#[doc = "GPIOD"]
pub struct Gpiod {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpiod {}
impl Gpiod {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio0::RegisterBlock = 0x4009_b000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gpiod {
    type Target = gpio0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpiod {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpiod").finish()
    }
}
#[doc = "GPIOD"]
pub use self::gpio0 as gpiod;
#[doc = "GPIOE"]
pub struct Gpioe {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpioe {}
impl Gpioe {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio0::RegisterBlock = 0x4009_d000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gpioe {
    type Target = gpio0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpioe {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpioe").finish()
    }
}
#[doc = "GPIOE"]
pub use self::gpio0 as gpioe;
#[doc = "GPIOF"]
pub struct Gpiof {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpiof {}
impl Gpiof {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio0::RegisterBlock = 0x4009_f000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gpiof {
    type Target = gpio0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpiof {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpiof").finish()
    }
}
#[doc = "GPIOF"]
pub use self::gpio0 as gpiof;
#[doc = "HFCG"]
pub struct Hfcg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Hfcg {}
impl Hfcg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const hfcg::RegisterBlock = 0x400b_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const hfcg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Hfcg {
    type Target = hfcg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Hfcg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Hfcg").finish()
    }
}
#[doc = "HFCG"]
pub mod hfcg;
#[doc = "I3C1"]
pub struct I3c1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I3c1 {}
impl I3c1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i3c1::RegisterBlock = 0x400f_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i3c1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I3c1 {
    type Target = i3c1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I3c1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I3c1").finish()
    }
}
#[doc = "I3C1"]
pub mod i3c1;
#[doc = "I3C2"]
pub struct I3c2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I3c2 {}
impl I3c2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i3c1::RegisterBlock = 0x400f_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i3c1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I3c2 {
    type Target = i3c1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I3c2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I3c2").finish()
    }
}
#[doc = "I3C2"]
pub use self::i3c1 as i3c2;
#[doc = "I3C3"]
pub struct I3c3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I3c3 {}
impl I3c3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i3c1::RegisterBlock = 0x400f_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i3c1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I3c3 {
    type Target = i3c1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I3c3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I3c3").finish()
    }
}
#[doc = "I3C3"]
pub use self::i3c1 as i3c3;
#[doc = "ITIM32_1"]
pub struct Itim32_1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Itim32_1 {}
impl Itim32_1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const itim32_1::RegisterBlock = 0x400b_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const itim32_1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Itim32_1 {
    type Target = itim32_1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Itim32_1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Itim32_1").finish()
    }
}
#[doc = "ITIM32_1"]
pub mod itim32_1;
#[doc = "ITIM32_2"]
pub struct Itim32_2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Itim32_2 {}
impl Itim32_2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const itim32_1::RegisterBlock = 0x400b_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const itim32_1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Itim32_2 {
    type Target = itim32_1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Itim32_2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Itim32_2").finish()
    }
}
#[doc = "ITIM32_2"]
pub use self::itim32_1 as itim32_2;
#[doc = "ITIM32_3"]
pub struct Itim32_3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Itim32_3 {}
impl Itim32_3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const itim32_1::RegisterBlock = 0x400b_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const itim32_1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Itim32_3 {
    type Target = itim32_1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Itim32_3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Itim32_3").finish()
    }
}
#[doc = "ITIM32_3"]
pub use self::itim32_1 as itim32_3;
#[doc = "ITIM32_4"]
pub struct Itim32_4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Itim32_4 {}
impl Itim32_4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const itim32_1::RegisterBlock = 0x400b_6000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const itim32_1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Itim32_4 {
    type Target = itim32_1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Itim32_4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Itim32_4").finish()
    }
}
#[doc = "ITIM32_4"]
pub use self::itim32_1 as itim32_4;
#[doc = "ITIM32_5"]
pub struct Itim32_5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Itim32_5 {}
impl Itim32_5 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const itim32_1::RegisterBlock = 0x400b_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const itim32_1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Itim32_5 {
    type Target = itim32_1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Itim32_5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Itim32_5").finish()
    }
}
#[doc = "ITIM32_5"]
pub use self::itim32_1 as itim32_5;
#[doc = "ITIM32_6"]
pub struct Itim32_6 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Itim32_6 {}
impl Itim32_6 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const itim32_1::RegisterBlock = 0x400b_a000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const itim32_1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Itim32_6 {
    type Target = itim32_1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Itim32_6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Itim32_6").finish()
    }
}
#[doc = "ITIM32_6"]
pub use self::itim32_1 as itim32_6;
#[doc = "ITIM64"]
pub struct Itim64 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Itim64 {}
impl Itim64 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const itim64::RegisterBlock = 0x400b_e000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const itim64::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Itim64 {
    type Target = itim64::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Itim64 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Itim64").finish()
    }
}
#[doc = "ITIM64"]
pub mod itim64;
#[doc = "KBC"]
pub struct Kbc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Kbc {}
impl Kbc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const kbc::RegisterBlock = 0x400c_7000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const kbc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Kbc {
    type Target = kbc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Kbc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Kbc").finish()
    }
}
#[doc = "KBC"]
pub mod kbc;
#[doc = "KBS"]
pub struct Kbs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Kbs {}
impl Kbs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const kbs::RegisterBlock = 0x400a_3000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const kbs::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Kbs {
    type Target = kbs::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Kbs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Kbs").finish()
    }
}
#[doc = "KBS"]
pub mod kbs;
#[doc = "LCT"]
pub struct Lct {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Lct {}
impl Lct {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const lct::RegisterBlock = 0x400d_7000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const lct::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Lct {
    type Target = lct::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Lct {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Lct").finish()
    }
}
#[doc = "LCT"]
pub mod lct;
#[doc = "LFCG"]
pub struct Lfcg {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Lfcg {}
impl Lfcg {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const lfcg::RegisterBlock = 0x400b_5100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const lfcg::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Lfcg {
    type Target = lfcg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Lfcg {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Lfcg").finish()
    }
}
#[doc = "LFCG"]
pub mod lfcg;
#[doc = "MDC"]
pub struct Mdc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mdc {}
impl Mdc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mdc::RegisterBlock = 0x4000_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mdc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mdc {
    type Target = mdc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mdc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mdc").finish()
    }
}
#[doc = "MDC"]
pub mod mdc;
#[doc = "MDMA1"]
pub struct Mdma1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mdma1 {}
impl Mdma1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mdma1::RegisterBlock = 0x4001_1100 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mdma1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mdma1 {
    type Target = mdma1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mdma1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mdma1").finish()
    }
}
#[doc = "MDMA1"]
pub mod mdma1;
#[doc = "MDMA2"]
pub struct Mdma2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mdma2 {}
impl Mdma2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mdma1::RegisterBlock = 0x4001_1200 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mdma1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mdma2 {
    type Target = mdma1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mdma2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mdma2").finish()
    }
}
#[doc = "MDMA2"]
pub use self::mdma1 as mdma2;
#[doc = "MDMA3"]
pub struct Mdma3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mdma3 {}
impl Mdma3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mdma1::RegisterBlock = 0x4001_1300 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mdma1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mdma3 {
    type Target = mdma1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mdma3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mdma3").finish()
    }
}
#[doc = "MDMA3"]
pub use self::mdma1 as mdma3;
#[doc = "MDMA4"]
pub struct Mdma4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mdma4 {}
impl Mdma4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mdma1::RegisterBlock = 0x4001_1400 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mdma1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mdma4 {
    type Target = mdma1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mdma4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mdma4").finish()
    }
}
#[doc = "MDMA4"]
pub use self::mdma1 as mdma4;
#[doc = "MDMA5"]
pub struct Mdma5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mdma5 {}
impl Mdma5 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mdma1::RegisterBlock = 0x4001_1500 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mdma1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mdma5 {
    type Target = mdma1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mdma5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mdma5").finish()
    }
}
#[doc = "MDMA5"]
pub use self::mdma1 as mdma5;
#[doc = "MDMA6"]
pub struct Mdma6 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mdma6 {}
impl Mdma6 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mdma1::RegisterBlock = 0x4001_1600 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mdma1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mdma6 {
    type Target = mdma1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mdma6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mdma6").finish()
    }
}
#[doc = "MDMA6"]
pub use self::mdma1 as mdma6;
#[doc = "MDMA7"]
pub struct Mdma7 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mdma7 {}
impl Mdma7 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mdma1::RegisterBlock = 0x4001_1700 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mdma1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mdma7 {
    type Target = mdma1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mdma7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mdma7").finish()
    }
}
#[doc = "MDMA7"]
pub use self::mdma1 as mdma7;
#[doc = "MFT16_1"]
pub struct Mft16_1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mft16_1 {}
impl Mft16_1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mft16_1::RegisterBlock = 0x400e_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mft16_1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mft16_1 {
    type Target = mft16_1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mft16_1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mft16_1").finish()
    }
}
#[doc = "MFT16_1"]
pub mod mft16_1;
#[doc = "MFT16_2"]
pub struct Mft16_2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mft16_2 {}
impl Mft16_2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mft16_1::RegisterBlock = 0x400e_3000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mft16_1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mft16_2 {
    type Target = mft16_1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mft16_2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mft16_2").finish()
    }
}
#[doc = "MFT16_2"]
pub use self::mft16_1 as mft16_2;
#[doc = "MFT16_3"]
pub struct Mft16_3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mft16_3 {}
impl Mft16_3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mft16_1::RegisterBlock = 0x400e_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mft16_1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mft16_3 {
    type Target = mft16_1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mft16_3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mft16_3").finish()
    }
}
#[doc = "MFT16_3"]
pub use self::mft16_1 as mft16_3;
#[doc = "MIWU0"]
pub struct Miwu0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Miwu0 {}
impl Miwu0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const miwu0::RegisterBlock = 0x400b_b000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const miwu0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Miwu0 {
    type Target = miwu0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Miwu0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Miwu0").finish()
    }
}
#[doc = "MIWU0"]
pub mod miwu0;
#[doc = "MIWU1"]
pub struct Miwu1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Miwu1 {}
impl Miwu1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const miwu0::RegisterBlock = 0x400b_d000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const miwu0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Miwu1 {
    type Target = miwu0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Miwu1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Miwu1").finish()
    }
}
#[doc = "MIWU1"]
pub use self::miwu0 as miwu1;
#[doc = "MIWU2"]
pub struct Miwu2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Miwu2 {}
impl Miwu2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const miwu0::RegisterBlock = 0x400b_f000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const miwu0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Miwu2 {
    type Target = miwu0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Miwu2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Miwu2").finish()
    }
}
#[doc = "MIWU2"]
pub use self::miwu0 as miwu2;
#[doc = "MSWC"]
pub struct Mswc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mswc {}
impl Mswc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mswc::RegisterBlock = 0x400c_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mswc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mswc {
    type Target = mswc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mswc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mswc").finish()
    }
}
#[doc = "MSWC"]
pub mod mswc;
#[doc = "MTC"]
pub struct Mtc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Mtc {}
impl Mtc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const mtc::RegisterBlock = 0x400b_7000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const mtc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Mtc {
    type Target = mtc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Mtc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Mtc").finish()
    }
}
#[doc = "MTC"]
pub mod mtc;
#[doc = "OTPI"]
pub struct Otpi {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Otpi {}
impl Otpi {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const otpi::RegisterBlock = 0x4000_7000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const otpi::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Otpi {
    type Target = otpi::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Otpi {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Otpi").finish()
    }
}
#[doc = "OTPI"]
pub mod otpi;
#[doc = "PECI"]
pub struct Peci {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Peci {}
impl Peci {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const peci::RegisterBlock = 0x400d_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const peci::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Peci {
    type Target = peci::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Peci {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Peci").finish()
    }
}
#[doc = "PECI"]
pub mod peci;
#[doc = "PM1"]
pub struct Pm1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pm1 {}
impl Pm1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pm1::RegisterBlock = 0x400c_9000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pm1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pm1 {
    type Target = pm1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pm1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pm1").finish()
    }
}
#[doc = "PM1"]
pub mod pm1;
#[doc = "PM2"]
pub struct Pm2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pm2 {}
impl Pm2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pm1::RegisterBlock = 0x400c_b000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pm1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pm2 {
    type Target = pm1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pm2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pm2").finish()
    }
}
#[doc = "PM2"]
pub use self::pm1 as pm2;
#[doc = "PM3"]
pub struct Pm3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pm3 {}
impl Pm3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pm1::RegisterBlock = 0x400c_d000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pm1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pm3 {
    type Target = pm1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pm3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pm3").finish()
    }
}
#[doc = "PM3"]
pub use self::pm1 as pm3;
#[doc = "PM4"]
pub struct Pm4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pm4 {}
impl Pm4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pm1::RegisterBlock = 0x400c_f000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pm1::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pm4 {
    type Target = pm1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pm4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pm4").finish()
    }
}
#[doc = "PM4"]
pub use self::pm1 as pm4;
#[doc = "PMC"]
pub struct Pmc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pmc {}
impl Pmc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pmc::RegisterBlock = 0x4000_d000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pmc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pmc {
    type Target = pmc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pmc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pmc").finish()
    }
}
#[doc = "PMC"]
pub mod pmc;
#[doc = "PS2"]
pub struct Ps2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ps2 {}
impl Ps2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ps2::RegisterBlock = 0x400b_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ps2::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Ps2 {
    type Target = ps2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ps2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ps2").finish()
    }
}
#[doc = "PS2"]
pub mod ps2;
#[doc = "PWM0"]
pub struct Pwm0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pwm0 {}
impl Pwm0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0::RegisterBlock = 0x4008_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pwm0 {
    type Target = pwm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pwm0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pwm0").finish()
    }
}
#[doc = "PWM0"]
pub mod pwm0;
#[doc = "PWM1"]
pub struct Pwm1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pwm1 {}
impl Pwm1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0::RegisterBlock = 0x4008_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pwm1 {
    type Target = pwm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pwm1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pwm1").finish()
    }
}
#[doc = "PWM1"]
pub use self::pwm0 as pwm1;
#[doc = "PWM2"]
pub struct Pwm2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pwm2 {}
impl Pwm2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0::RegisterBlock = 0x4008_4000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pwm2 {
    type Target = pwm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pwm2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pwm2").finish()
    }
}
#[doc = "PWM2"]
pub use self::pwm0 as pwm2;
#[doc = "PWM3"]
pub struct Pwm3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pwm3 {}
impl Pwm3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0::RegisterBlock = 0x4008_6000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pwm3 {
    type Target = pwm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pwm3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pwm3").finish()
    }
}
#[doc = "PWM3"]
pub use self::pwm0 as pwm3;
#[doc = "PWM4"]
pub struct Pwm4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pwm4 {}
impl Pwm4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0::RegisterBlock = 0x4008_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pwm4 {
    type Target = pwm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pwm4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pwm4").finish()
    }
}
#[doc = "PWM4"]
pub use self::pwm0 as pwm4;
#[doc = "PWM5"]
pub struct Pwm5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pwm5 {}
impl Pwm5 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0::RegisterBlock = 0x4008_a000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pwm5 {
    type Target = pwm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pwm5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pwm5").finish()
    }
}
#[doc = "PWM5"]
pub use self::pwm0 as pwm5;
#[doc = "PWM6"]
pub struct Pwm6 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pwm6 {}
impl Pwm6 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0::RegisterBlock = 0x4008_c000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pwm6 {
    type Target = pwm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pwm6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pwm6").finish()
    }
}
#[doc = "PWM6"]
pub use self::pwm0 as pwm6;
#[doc = "PWM7"]
pub struct Pwm7 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pwm7 {}
impl Pwm7 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pwm0::RegisterBlock = 0x4008_e000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pwm0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pwm7 {
    type Target = pwm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pwm7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pwm7").finish()
    }
}
#[doc = "PWM7"]
pub use self::pwm0 as pwm7;
#[doc = "SHI"]
pub struct Shi {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Shi {}
impl Shi {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const shi::RegisterBlock = 0x4000_f000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const shi::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Shi {
    type Target = shi::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Shi {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Shi").finish()
    }
}
#[doc = "SHI"]
pub mod shi;
#[doc = "SHM"]
pub struct Shm {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Shm {}
impl Shm {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const shm::RegisterBlock = 0x4001_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const shm::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Shm {
    type Target = shm::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Shm {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Shm").finish()
    }
}
#[doc = "SHM"]
pub mod shm;
#[doc = "ESHM"]
pub struct Eshm {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Eshm {}
impl Eshm {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const eshm::RegisterBlock = 0x4001_0080 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const eshm::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Eshm {
    type Target = eshm::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Eshm {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Eshm").finish()
    }
}
#[doc = "ESHM"]
pub mod eshm;
#[doc = "SMB0"]
pub struct Smb0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Smb0 {}
impl Smb0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const smb0::RegisterBlock = 0x4000_9000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const smb0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Smb0 {
    type Target = smb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Smb0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Smb0").finish()
    }
}
#[doc = "SMB0"]
pub mod smb0;
#[doc = "SMB1"]
pub struct Smb1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Smb1 {}
impl Smb1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const smb0::RegisterBlock = 0x4000_b000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const smb0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Smb1 {
    type Target = smb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Smb1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Smb1").finish()
    }
}
#[doc = "SMB1"]
pub use self::smb0 as smb1;
#[doc = "SMB2"]
pub struct Smb2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Smb2 {}
impl Smb2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const smb0::RegisterBlock = 0x400c_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const smb0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Smb2 {
    type Target = smb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Smb2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Smb2").finish()
    }
}
#[doc = "SMB2"]
pub use self::smb0 as smb2;
#[doc = "SMB3"]
pub struct Smb3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Smb3 {}
impl Smb3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const smb0::RegisterBlock = 0x400c_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const smb0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Smb3 {
    type Target = smb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Smb3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Smb3").finish()
    }
}
#[doc = "SMB3"]
pub use self::smb0 as smb3;
#[doc = "SMB4"]
pub struct Smb4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Smb4 {}
impl Smb4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const smb0::RegisterBlock = 0x4000_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const smb0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Smb4 {
    type Target = smb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Smb4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Smb4").finish()
    }
}
#[doc = "SMB4"]
pub use self::smb0 as smb4;
#[doc = "SMB5"]
pub struct Smb5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Smb5 {}
impl Smb5 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const smb0::RegisterBlock = 0x4001_7000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const smb0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Smb5 {
    type Target = smb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Smb5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Smb5").finish()
    }
}
#[doc = "SMB5"]
pub use self::smb0 as smb5;
#[doc = "SMB6"]
pub struct Smb6 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Smb6 {}
impl Smb6 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const smb0::RegisterBlock = 0x4001_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const smb0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Smb6 {
    type Target = smb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Smb6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Smb6").finish()
    }
}
#[doc = "SMB6"]
pub use self::smb0 as smb6;
#[doc = "SMB7"]
pub struct Smb7 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Smb7 {}
impl Smb7 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const smb0::RegisterBlock = 0x4001_9000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const smb0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Smb7 {
    type Target = smb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Smb7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Smb7").finish()
    }
}
#[doc = "SMB7"]
pub use self::smb0 as smb7;
#[doc = "SPIP"]
pub struct Spip {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Spip {}
impl Spip {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const spip::RegisterBlock = 0x400d_2000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const spip::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Spip {
    type Target = spip::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Spip {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Spip").finish()
    }
}
#[doc = "SPIP"]
pub mod spip;
#[doc = "SYS CONFIG"]
pub struct Sysconfig {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Sysconfig {}
impl Sysconfig {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const sysconfig::RegisterBlock = 0x400c_3000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const sysconfig::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Sysconfig {
    type Target = sysconfig::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Sysconfig {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Sysconfig").finish()
    }
}
#[doc = "SYS CONFIG"]
pub mod sysconfig;
#[doc = "SYS GLUE"]
pub struct Sysglue {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Sysglue {}
impl Sysglue {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const sysglue::RegisterBlock = 0x400a_5000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const sysglue::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Sysglue {
    type Target = sysglue::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Sysglue {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Sysglue").finish()
    }
}
#[doc = "SYS GLUE"]
pub mod sysglue;
#[doc = "TWD"]
pub struct Twd {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Twd {}
impl Twd {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const twd::RegisterBlock = 0x400d_8000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const twd::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Twd {
    type Target = twd::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Twd {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Twd").finish()
    }
}
#[doc = "TWD"]
pub mod twd;
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "ADC_IREF"]
    pub adc_iref: AdcIref,
    #[doc = "ADC_EREF"]
    pub adc_eref: AdcEref,
    #[doc = "BBRM"]
    pub bbrm: Bbrm,
    #[doc = "CORE2HOST"]
    pub core2host: Core2host,
    #[doc = "CR_UART1"]
    pub cr_uart1: CrUart1,
    #[doc = "CR_UART2"]
    pub cr_uart2: CrUart2,
    #[doc = "CR_UART3"]
    pub cr_uart3: CrUart3,
    #[doc = "CR_UART4"]
    pub cr_uart4: CrUart4,
    #[doc = "DEV"]
    pub dev: Dev,
    #[doc = "ESPI"]
    pub espi: Espi,
    #[doc = "FIU_0"]
    pub fiu_0: Fiu0,
    #[doc = "FIU_1"]
    pub fiu_1: Fiu1,
    #[doc = "FLM"]
    pub flm: Flm,
    #[doc = "GDMA1"]
    pub gdma1: Gdma1,
    #[doc = "GDMA2"]
    pub gdma2: Gdma2,
    #[doc = "GPIO0"]
    pub gpio0: Gpio0,
    #[doc = "GPIO1"]
    pub gpio1: Gpio1,
    #[doc = "GPIO2"]
    pub gpio2: Gpio2,
    #[doc = "GPIO3"]
    pub gpio3: Gpio3,
    #[doc = "GPIO4"]
    pub gpio4: Gpio4,
    #[doc = "GPIO5"]
    pub gpio5: Gpio5,
    #[doc = "GPIO6"]
    pub gpio6: Gpio6,
    #[doc = "GPIO7"]
    pub gpio7: Gpio7,
    #[doc = "GPIO8"]
    pub gpio8: Gpio8,
    #[doc = "GPIO9"]
    pub gpio9: Gpio9,
    #[doc = "GPIOA"]
    pub gpioa: Gpioa,
    #[doc = "GPIOB"]
    pub gpiob: Gpiob,
    #[doc = "GPIOC"]
    pub gpioc: Gpioc,
    #[doc = "GPIOD"]
    pub gpiod: Gpiod,
    #[doc = "GPIOE"]
    pub gpioe: Gpioe,
    #[doc = "GPIOF"]
    pub gpiof: Gpiof,
    #[doc = "HFCG"]
    pub hfcg: Hfcg,
    #[doc = "I3C1"]
    pub i3c1: I3c1,
    #[doc = "I3C2"]
    pub i3c2: I3c2,
    #[doc = "I3C3"]
    pub i3c3: I3c3,
    #[doc = "ITIM32_1"]
    pub itim32_1: Itim32_1,
    #[doc = "ITIM32_2"]
    pub itim32_2: Itim32_2,
    #[doc = "ITIM32_3"]
    pub itim32_3: Itim32_3,
    #[doc = "ITIM32_4"]
    pub itim32_4: Itim32_4,
    #[doc = "ITIM32_5"]
    pub itim32_5: Itim32_5,
    #[doc = "ITIM32_6"]
    pub itim32_6: Itim32_6,
    #[doc = "ITIM64"]
    pub itim64: Itim64,
    #[doc = "KBC"]
    pub kbc: Kbc,
    #[doc = "KBS"]
    pub kbs: Kbs,
    #[doc = "LCT"]
    pub lct: Lct,
    #[doc = "LFCG"]
    pub lfcg: Lfcg,
    #[doc = "MDC"]
    pub mdc: Mdc,
    #[doc = "MDMA1"]
    pub mdma1: Mdma1,
    #[doc = "MDMA2"]
    pub mdma2: Mdma2,
    #[doc = "MDMA3"]
    pub mdma3: Mdma3,
    #[doc = "MDMA4"]
    pub mdma4: Mdma4,
    #[doc = "MDMA5"]
    pub mdma5: Mdma5,
    #[doc = "MDMA6"]
    pub mdma6: Mdma6,
    #[doc = "MDMA7"]
    pub mdma7: Mdma7,
    #[doc = "MFT16_1"]
    pub mft16_1: Mft16_1,
    #[doc = "MFT16_2"]
    pub mft16_2: Mft16_2,
    #[doc = "MFT16_3"]
    pub mft16_3: Mft16_3,
    #[doc = "MIWU0"]
    pub miwu0: Miwu0,
    #[doc = "MIWU1"]
    pub miwu1: Miwu1,
    #[doc = "MIWU2"]
    pub miwu2: Miwu2,
    #[doc = "MSWC"]
    pub mswc: Mswc,
    #[doc = "MTC"]
    pub mtc: Mtc,
    #[doc = "OTPI"]
    pub otpi: Otpi,
    #[doc = "PECI"]
    pub peci: Peci,
    #[doc = "PM1"]
    pub pm1: Pm1,
    #[doc = "PM2"]
    pub pm2: Pm2,
    #[doc = "PM3"]
    pub pm3: Pm3,
    #[doc = "PM4"]
    pub pm4: Pm4,
    #[doc = "PMC"]
    pub pmc: Pmc,
    #[doc = "PS2"]
    pub ps2: Ps2,
    #[doc = "PWM0"]
    pub pwm0: Pwm0,
    #[doc = "PWM1"]
    pub pwm1: Pwm1,
    #[doc = "PWM2"]
    pub pwm2: Pwm2,
    #[doc = "PWM3"]
    pub pwm3: Pwm3,
    #[doc = "PWM4"]
    pub pwm4: Pwm4,
    #[doc = "PWM5"]
    pub pwm5: Pwm5,
    #[doc = "PWM6"]
    pub pwm6: Pwm6,
    #[doc = "PWM7"]
    pub pwm7: Pwm7,
    #[doc = "SHI"]
    pub shi: Shi,
    #[doc = "SHM"]
    pub shm: Shm,
    #[doc = "ESHM"]
    pub eshm: Eshm,
    #[doc = "SMB0"]
    pub smb0: Smb0,
    #[doc = "SMB1"]
    pub smb1: Smb1,
    #[doc = "SMB2"]
    pub smb2: Smb2,
    #[doc = "SMB3"]
    pub smb3: Smb3,
    #[doc = "SMB4"]
    pub smb4: Smb4,
    #[doc = "SMB5"]
    pub smb5: Smb5,
    #[doc = "SMB6"]
    pub smb6: Smb6,
    #[doc = "SMB7"]
    pub smb7: Smb7,
    #[doc = "SPIP"]
    pub spip: Spip,
    #[doc = "SYS CONFIG"]
    pub sysconfig: Sysconfig,
    #[doc = "SYS GLUE"]
    pub sysglue: Sysglue,
    #[doc = "TWD"]
    pub twd: Twd,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            adc_iref: AdcIref::steal(),
            adc_eref: AdcEref::steal(),
            bbrm: Bbrm::steal(),
            core2host: Core2host::steal(),
            cr_uart1: CrUart1::steal(),
            cr_uart2: CrUart2::steal(),
            cr_uart3: CrUart3::steal(),
            cr_uart4: CrUart4::steal(),
            dev: Dev::steal(),
            espi: Espi::steal(),
            fiu_0: Fiu0::steal(),
            fiu_1: Fiu1::steal(),
            flm: Flm::steal(),
            gdma1: Gdma1::steal(),
            gdma2: Gdma2::steal(),
            gpio0: Gpio0::steal(),
            gpio1: Gpio1::steal(),
            gpio2: Gpio2::steal(),
            gpio3: Gpio3::steal(),
            gpio4: Gpio4::steal(),
            gpio5: Gpio5::steal(),
            gpio6: Gpio6::steal(),
            gpio7: Gpio7::steal(),
            gpio8: Gpio8::steal(),
            gpio9: Gpio9::steal(),
            gpioa: Gpioa::steal(),
            gpiob: Gpiob::steal(),
            gpioc: Gpioc::steal(),
            gpiod: Gpiod::steal(),
            gpioe: Gpioe::steal(),
            gpiof: Gpiof::steal(),
            hfcg: Hfcg::steal(),
            i3c1: I3c1::steal(),
            i3c2: I3c2::steal(),
            i3c3: I3c3::steal(),
            itim32_1: Itim32_1::steal(),
            itim32_2: Itim32_2::steal(),
            itim32_3: Itim32_3::steal(),
            itim32_4: Itim32_4::steal(),
            itim32_5: Itim32_5::steal(),
            itim32_6: Itim32_6::steal(),
            itim64: Itim64::steal(),
            kbc: Kbc::steal(),
            kbs: Kbs::steal(),
            lct: Lct::steal(),
            lfcg: Lfcg::steal(),
            mdc: Mdc::steal(),
            mdma1: Mdma1::steal(),
            mdma2: Mdma2::steal(),
            mdma3: Mdma3::steal(),
            mdma4: Mdma4::steal(),
            mdma5: Mdma5::steal(),
            mdma6: Mdma6::steal(),
            mdma7: Mdma7::steal(),
            mft16_1: Mft16_1::steal(),
            mft16_2: Mft16_2::steal(),
            mft16_3: Mft16_3::steal(),
            miwu0: Miwu0::steal(),
            miwu1: Miwu1::steal(),
            miwu2: Miwu2::steal(),
            mswc: Mswc::steal(),
            mtc: Mtc::steal(),
            otpi: Otpi::steal(),
            peci: Peci::steal(),
            pm1: Pm1::steal(),
            pm2: Pm2::steal(),
            pm3: Pm3::steal(),
            pm4: Pm4::steal(),
            pmc: Pmc::steal(),
            ps2: Ps2::steal(),
            pwm0: Pwm0::steal(),
            pwm1: Pwm1::steal(),
            pwm2: Pwm2::steal(),
            pwm3: Pwm3::steal(),
            pwm4: Pwm4::steal(),
            pwm5: Pwm5::steal(),
            pwm6: Pwm6::steal(),
            pwm7: Pwm7::steal(),
            shi: Shi::steal(),
            shm: Shm::steal(),
            eshm: Eshm::steal(),
            smb0: Smb0::steal(),
            smb1: Smb1::steal(),
            smb2: Smb2::steal(),
            smb3: Smb3::steal(),
            smb4: Smb4::steal(),
            smb5: Smb5::steal(),
            smb6: Smb6::steal(),
            smb7: Smb7::steal(),
            spip: Spip::steal(),
            sysconfig: Sysconfig::steal(),
            sysglue: Sysglue::steal(),
            twd: Twd::steal(),
        }
    }
}
